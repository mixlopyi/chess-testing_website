<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --danger: #f72585;
            --success: #4cc9f0;
            --warning: #f8961e;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --white: #ffffff;
            --card-bg: rgba(255, 255, 255, 0.9);
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
            --border-radius: 12px;
            --border-radius-sm: 8px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            color: var(--dark);
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 2rem;
            font-weight: 700;
            font-size: 2.5rem;
            letter-spacing: -0.5px;
        }

        .control-panel {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 1.5rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 200px;
            flex-grow: 1;
        }

        label {
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--dark);
            font-size: 0.9rem;
        }

        select, input {
            padding: 0.75rem 1rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius-sm);
            font-size: 0.95rem;
            background: var(--white);
            transition: var(--transition);
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }

        button {
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-sm);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            border: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #generate-btn {
            background-color: var(--gray);
            color: var(--white);
        }

        #generate-btn:hover {
            background-color: #5a6268;
        }

        #start-btn {
            background-color: var(--primary);
            color: var(--white);
        }

        #start-btn:hover {
            background-color: var(--primary-dark);
            box-shadow: var(--shadow);
        }

        #reset-btn {
            background-color: var(--warning);
            color: var(--white);
        }

        #reset-btn:hover {
            background-color: #e68a19;
        }

        button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            transform: none;
            opacity: 0.7;
        }

        #array-input {
            flex-grow: 1;
        }

        #visualization {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            height: 400px;
            display: flex;
            align-items: flex-end;
            gap: 4px;
            margin-bottom: 1.5rem;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .bar {
            background-color: var(--primary);
            transition: all 0.3s ease;
            flex-grow: 1;
            position: relative;
            border-radius: 4px 4px 0 0;
        }

        .bar.comparing {
            background-color: var(--danger);
        }

        .bar.sorted {
            background-color: var(--success);
        }

        .bar.pivot {
            background-color: var(--warning);
        }

        .bar.min {
            background-color: var(--secondary);
        }

        .info-panel {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .algorithm-info, .time-calculation {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            flex: 1;
            min-width: 300px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .algorithm-info h3, .time-calculation h3 {
            margin-top: 0;
            color: var(--primary);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 0.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .pseudo-code {
            background: rgba(248, 249, 250, 0.7);
            padding: 1rem;
            border-radius: var(--border-radius-sm);
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            white-space: pre-wrap;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            line-height: 1.5;
            overflow-x: auto;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .time-complexity {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .complexity-case {
            flex: 1;
            padding: 1rem;
            border-radius: var(--border-radius-sm);
            background: rgba(248, 249, 250, 0.7);
            min-width: 120px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .complexity-case h4 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            color: var(--dark);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .execution-time {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 1rem;
        }

        .time-equation {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(248, 249, 250, 0.7);
            border-radius: var(--border-radius-sm);
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .speed-value {
            min-width: 30px;
            text-align: center;
            font-weight: 500;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: #dee2e6;
            border-radius: 3px;
            flex-grow: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: var(--primary-dark);
        }

        /* New styles for array displays */
        .array-display-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .array-display {
            background: var(--card-bg);
            border-radius: var(--border-radius-sm);
            padding: 0.75rem 1rem;
            font-family: 'SF Mono', 'Roboto Mono', monospace;
            font-size: 0.9rem;
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: var(--shadow);
        }

        .array-display strong {
            font-weight: 500;
            color: var(--primary);
            margin-right: 0.5rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
        
            .control-row {
                flex-direction: column;
            }
        
            .control-group {
                width: 100%;
            }
        
            .info-panel {
                flex-direction: column;
            }
        
            button {
                width: 100%;
            }
        }

        /* Animation for bars */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .bar.comparing {
            animation: pulse 0.5s ease infinite;
        }
        body.dark-mode {
    background: linear-gradient(135deg, #121212 0%, #1a1a1a 100%);
    color: #e0e0e0;
}

body.dark-mode .control-panel,
body.dark-mode .array-display,
body.dark-mode .algorithm-info,
body.dark-mode .time-calculation {
    background: rgba(30, 30, 30, 0.95);
    color: #e0e0e0;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

body.dark-mode h1 {
    color: #7c9eff;
}

body.dark-mode h3 {
    color: #7c9eff;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

body.dark-mode label {
    color: #bbbbbb;
}

body.dark-mode .bar {
    background-color: #5d7eff;
}

body.dark-mode .bar.sorted {
    background-color: #4cc9f0;
}

body.dark-mode .bar.comparing {
    background-color: #ff5d8f;
}

body.dark-mode .bar.pivot {
    background-color: #ff9e5d;
}

body.dark-mode .bar.min {
    background-color: #6d5dff;
}

body.dark-mode input,
body.dark-mode select {
    background: #2d2d2d;
    color: #e0e0e0;
    border-color: rgba(255, 255, 255, 0.1);
}

body.dark-mode input:focus,
body.dark-mode select:focus {
    border-color: #7c9eff;
    box-shadow: 0 0 0 3px rgba(124, 158, 255, 0.2);
}

body.dark-mode button {
    background-color: #3a3a3a;
    color: #e0e0e0;
}

body.dark-mode #generate-btn {
    background-color: #5a6268;
}

body.dark-mode #generate-btn:hover {
    background-color: #6c757d;
}

body.dark-mode #start-btn {
    background-color: #4361ee;
    color: white;
}

body.dark-mode #start-btn:hover {
    background-color: #3a56d4;
}

body.dark-mode #reset-btn {
    background-color: #f8961e;
    color: white;
}

body.dark-mode #reset-btn:hover {
    background-color: #e68a19;
}

body.dark-mode button:disabled {
    background-color: #4a4a4a;
    color: #777777;
}

body.dark-mode .pseudo-code,
body.dark-mode .time-equation,
body.dark-mode .complexity-case {
    background: rgba(40, 40, 40, 0.8);
    color: #d0d0d0;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

body.dark-mode .pseudo-code {
    color: #a5d6ff;
}

body.dark-mode .complexity-case h4 {
    color: #bbbbbb;
}

body.dark-mode .execution-time {
    color: #e0e0e0;
}

body.dark-mode input[type="range"] {
    background: #4a4a4a;
}

body.dark-mode input[type="range"]::-webkit-slider-thumb {
    background: #7c9eff;
}

body.dark-mode input[type="range"]::-webkit-slider-thumb:hover {
    background: #6d8eff;
}

body.dark-mode .array-display strong {
    color: #7c9eff;
}

/* Dark mode toggle styling */
body.dark-mode #dark-mode-toggle {
    filter: invert(1);
}

body.dark-mode #dark-mode-toggle + label {
    color: #e0e0e0;
}

    </style>
</head>
<body>
    <div class="container">
        <h1>Sorting Algorithms Visualizer</h1>
        <div style="text-align: center; margin-bottom: 1rem;">
            <label>
                <input type="checkbox" id="dark-mode-toggle"> Dark Mode 🌙
            </label>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group">
                    <label for="algorithm">Sorting Algorithm</label>
                    <select id="algorithm">
                        <option value="bubble">Bubble Sort</option>
                        <option value="insertion">Insertion Sort</option>
                        <option value="selection">Selection Sort</option>
                        <option value="merge">Merge Sort</option>
                        <option value="quick">Quick Sort</option>
                        <option value="heap">Heap Sort</option>
                        <option value="shell">Shell Sort</option>
                        <option value="counting">Counting Sort</option>
                        <option value="radix">Radix Sort</option>
                        <option value="bucket">Bucket Sort</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="array-size">Array Size</label>
                    <input type="number" id="array-size" min="3" max="50" value="15">
                </div>
                <div class="control-group">
                    <label for="array-type">Array Type</label>
                    <select id="array-type">
                        <option value="random">Random</option>
                        <option value="sorted">Sorted</option>
                        <option value="reverse">Reverse Sorted</option>
                        <option value="almost">Almost Sorted</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div class="control-group speed-control">
                    <label for="speed">Speed</label>
                    <input type="range" id="speed" min="1" max="20" value="10">
                    <span class="speed-value" id="speed-value">10</span>
                </div>
            </div>
            
            <div class="control-row" id="custom-array-row" style="display: none;">
                <div class="control-group" style="flex-grow: 1;">
                    <label for="array-input">Custom Array (comma separated numbers)</label>
                    <input type="text" id="array-input" placeholder="e.g. 5, 3, 8, 1, 2">
                </div>
            </div>
            
            <div class="control-row">
                <button id="generate-btn">Generate New Array</button>
                <button id="start-btn">Start Sorting</button>
                <button id="reset-btn" disabled>Reset</button>
            </div>
        </div>
        
        <div class="array-display-container">
            <div class="array-display">
                <strong>Original Array:</strong> 
                <span id="original-array"></span>
            </div>
            <div class="array-display">
                <strong>Current Array:</strong> 
                <span id="current-array"></span>
            </div>
            <div class="array-display">
                <strong>Sorted Array:</strong> 
                <span id="sorted-array"></span>
            </div>
        </div>
        
        <div id="visualization"></div>
        
        <div class="info-panel">
            <div class="algorithm-info">
                <h3>Algorithm Information</h3>
                <div id="pseudo-code" class="pseudo-code">
                    Select an algorithm to see its pseudocode
                </div>
                <div class="time-complexity">
                    <div class="complexity-case">
                        <h4>Best Case</h4>
                        <div id="best-case">Ω(?)</div>
                    </div>
                    <div class="complexity-case">
                        <h4>Average Case</h4>
                        <div id="average-case">Θ(?)</div>
                    </div>
                    <div class="complexity-case">
                        <h4>Worst Case</h4>
                        <div id="worst-case">O(?)</div>
                    </div>
                </div>
            </div>
            
            <div class="time-calculation">
                <h3>Time Calculation</h3>
                <div class="execution-time">
                    Execution Time: <span id="actual-time">Not run yet</span>
                </div>
                <div id="time-equation" class="time-equation">
                    The time complexity equation will appear here after sorting completes.
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const visualization = document.getElementById('visualization');
        const algorithmSelect = document.getElementById('algorithm');
        const arraySizeInput = document.getElementById('array-size');
        const arrayTypeSelect = document.getElementById('array-type');
        const arrayInput = document.getElementById('array-input');
        const customArrayRow = document.getElementById('custom-array-row');
        const generateBtn = document.getElementById('generate-btn');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedControl = document.getElementById('speed');
        const speedValue = document.getElementById('speed-value');
        const pseudoCodeElement = document.getElementById('pseudo-code');
        const bestCaseElement = document.getElementById('best-case');
        const averageCaseElement = document.getElementById('average-case');
        const worstCaseElement = document.getElementById('worst-case');
        const actualTimeElement = document.getElementById('actual-time');
        const timeEquationElement = document.getElementById('time-equation');

        // State variables
        let array = [];
        let originalArray = [];
        let sortedArray = [];
        let isSorting = false;
        let animationSpeed = 1000 / 10; // Default speed (10)
        let startTime, endTime;
        let animationFrames = [];
        let currentFrame = 0;

        // Algorithm information
        const algorithmInfo = {
            bubble: {
                name: "Bubble Sort",
                pseudoCode: `procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n-1 inclusive do
            if A[i-1] > A[i] then
                swap(A[i-1], A[i])
                swapped = true
            end if
        end for
        n := n - 1
    until not swapped
end procedure`,
                bestCase: "O(n)",
                averageCase: "O(n²)",
                worstCase: "O(n²)",
                explanation: "Bubble sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order."
            },
            insertion: {
                name: "Insertion Sort",
                pseudoCode: `procedure insertionSort(A : list of sortable items)
    for i := 1 to length(A) - 1 do
        key := A[i]
        j := i - 1
        while j >= 0 and A[j] > key do
            A[j+1] := A[j]
            j := j - 1
        end while
        A[j+1] := key
    end for
end procedure`,
                bestCase: "O(n)",
                averageCase: "O(n²)",
                worstCase: "O(n²)",
                explanation: "Insertion sort builds the final sorted array one item at a time by repeatedly taking the next item and inserting it into the correct position."
            },
            selection: {
                name: "Selection Sort",
                pseudoCode: `procedure selectionSort(A : list of sortable items)
    n := length(A)
    for i := 0 to n-2 do
        minIndex := i
        for j := i+1 to n-1 do
            if A[j] < A[minIndex] then
                minIndex := j
            end if
        end for
        if minIndex != i then
            swap(A[i], A[minIndex])
        end if
    end for
end procedure`,
                bestCase: "O(n²)",
                averageCase: "O(n²)",
                worstCase: "O(n²)",
                explanation: "Selection sort divides the input into a sorted and unsorted region, and repeatedly selects the smallest element from the unsorted region and moves it to the sorted region."
            },
            merge: {
                name: "Merge Sort",
                pseudoCode: `procedure mergeSort(A : list of sortable items)
    if length(A) <= 1 then
        return A
    end if
    
    middle := length(A) / 2
    left := A[0..middle-1]
    right := A[middle..length(A)-1]
    
    left := mergeSort(left)
    right := mergeSort(right)
    
    return merge(left, right)
end procedure

procedure merge(left, right)
    result := []
    while left is not empty and right is not empty do
        if first(left) <= first(right) then
            append first(left) to result
            left := rest(left)
        else
            append first(right) to result
            right := rest(right)
        end if
    end while
    
    while left is not empty do
        append first(left) to result
        left := rest(left)
    end while
    
    while right is not empty do
        append first(right) to result
        right := rest(right)
    end while
    
    return result
end procedure`,
                bestCase: "O(n log n)",
                averageCase: "O(n log n)",
                worstCase: "O(n log n)",
                explanation: "Merge sort is a divide-and-conquer algorithm that recursively divides the list into halves, sorts them, and then merges the sorted halves."
            },
            quick: {
                name: "Quick Sort",
                pseudoCode: `procedure quickSort(A : list of sortable items, low, high)
    if low < high then
        p := partition(A, low, high)
        quickSort(A, low, p - 1)
        quickSort(A, p + 1, high)
    end if
end procedure

procedure partition(A, low, high)
    pivot := A[high]
    i := low
    for j := low to high-1 do
        if A[j] < pivot then
            swap(A[i], A[j])
            i := i + 1
        end if
    end for
    swap(A[i], A[high])
    return i
end procedure`,
                bestCase: "O(n log n)",
                averageCase: "O(n log n)",
                worstCase: "O(n²)",
                explanation: "Quick sort is a divide-and-conquer algorithm that selects a 'pivot' element and partitions the array around the pivot, placing smaller elements before it and larger elements after it."
            },
            heap: {
                name: "Heap Sort",
                pseudoCode: `procedure heapSort(A : list of sortable items)
    n := length(A)
    // Build max heap
    for i := floor(n/2) - 1 downto 0 do
        heapify(A, n, i)
    end for
    
    // Extract elements from heap
    for i := n-1 downto 1 do
        swap(A[0], A[i])
        heapify(A, i, 0)
    end for
end procedure

procedure heapify(A, n, i)
    largest := i
    left := 2*i + 1
    right := 2*i + 2
    
    if left < n and A[left] > A[largest] then
        largest = left
    end if
    
    if right < n and A[right] > A[largest] then
        largest = right
    end if
    
    if largest != i then
        swap(A[i], A[largest])
        heapify(A, n, largest)
    end if
end procedure`,
                bestCase: "O(n log n)",
                averageCase: "O(n log n)",
                worstCase: "O(n log n)",
                explanation: "Heap sort converts the array into a max-heap, then repeatedly extracts the maximum element from the heap and rebuilds the heap."
            },
            shell: {
                name: "Shell Sort",
                pseudoCode: `procedure shellSort(A : list of sortable items)
    n := length(A)
    gap := floor(n/2)
    
    while gap > 0 do
        for i := gap to n-1 do
            temp := A[i]
            j := i
            while j >= gap and A[j-gap] > temp do
                A[j] := A[j-gap]
                j := j - gap
            end while
            A[j] := temp
        end for
        gap := floor(gap/2)
    end while
end procedure`,
                bestCase: "O(n log n)",
                averageCase: "Between O(n log n) and O(n²)",
                worstCase: "O(n²)",
                explanation: "Shell sort is a generalization of insertion sort that allows the exchange of items that are far apart by using a sequence of gaps. Performance depends on the gap sequence used."
            },
            counting: {
                name: "Counting Sort",
                pseudoCode: `procedure countingSort(A : list of sortable items)
    n := length(A)
    max := findMax(A)
    min := findMin(A)
    range := max - min + 1
    
    // Initialize count and output arrays
    count := array of size range initialized to 0
    output := array of size n
    
    // Store count of each element
    for i := 0 to n-1 do
        count[A[i] - min] := count[A[i] - min] + 1
    end for
    
    // Change count[i] to be the position of i in output
    for i := 1 to range-1 do
        count[i] := count[i] + count[i-1]
    end for
    
    // Build the output array
    for i := n-1 downto 0 do
        output[count[A[i] - min] - 1] := A[i]
        count[A[i] - min] := count[A[i] - min] - 1
    end for
    
    // Copy output to original array
    for i := 0 to n-1 do
        A[i] := output[i]
    end for
end procedure`,
                bestCase: "O(n + k)",
                averageCase: "O(n + k)",
                worstCase: "O(n + k)",
                explanation: "Counting sort works by counting the number of objects that have distinct key values, then doing arithmetic to calculate the positions of each key in the output sequence. 'n' is the number of elements, 'k' is the range of input values."
            },
            radix: {
                name: "Radix Sort",
                pseudoCode: `procedure radixSort(A : list of sortable items)
    // Split into negatives and positives
    negatives := A filtered for x where x < 0, mapped to -x
    positives := A filtered for x where x >= 0
    
    // Sort negatives (as positives, then reverse and negate)
    if negatives is not empty then
        radixSortHelper(negatives)
        reverse(negatives)
        for i := 0 to length(negatives)-1 do
            negatives[i] := -negatives[i]
        end for
    end if
    
    // Sort positives
    if positives is not empty then
        radixSortHelper(positives)
    end if
    
    // Combine results
    A := concatenate(negatives, positives)
end procedure

procedure radixSortHelper(A)
    max := findMax(A)
    for exp := 1 while max/exp > 0 do
        countingSortByDigit(A, exp)
        exp := exp * 10
    end for
end procedure

procedure countingSortByDigit(A, exp)
    n := length(A)
    output := array of size n
    count := array of size 10 initialized to 0
    
    for i := 0 to n-1 do
        digit := floor(A[i]/exp) % 10
        count[digit] := count[digit] + 1
    end for
    
    for i := 1 to 9 do
        count[i] := count[i] + count[i-1]
    end for
    
    for i := n-1 downto 0 do
        digit := floor(A[i]/exp) % 10
        output[count[digit]-1] := A[i]
        count[digit] := count[digit] - 1
    end for
    
    for i := 0 to n-1 do
        A[i] := output[i]
    end for
end procedure`,
                bestCase: "O(nk)",
                averageCase: "O(nk)",
                worstCase: "O(nk)",
                explanation: "Radix sort processes the digits of numbers by grouping numbers by each digit, starting from the least significant digit to the most significant. 'n' is the number of elements, 'k' is the number of digits or max key length."
            },
            bucket: {
                name: "Bucket Sort",
                pseudoCode: `procedure bucketSort(A : list of sortable items)
    n := length(A)
    if n <= 0 then return end if
    
    maxVal := findMax(A)
    minVal := findMin(A)
    range := maxVal - minVal + 1
    bucketCount := floor(sqrt(n))
    buckets := array of bucketCount empty lists
    
    // Scatter elements into buckets
    for i := 0 to n-1 do
        normalized := (A[i] - minVal) / range
        bucketIdx := min(floor(normalized * bucketCount), bucketCount - 1)
        append A[i] to buckets[bucketIdx]
    end for
    
    // Sort individual buckets
    for i := 0 to bucketCount-1 do
        insertionSort(buckets[i])
    end for
    
    // Concatenate all buckets
    index := 0
    for i := 0 to bucketCount-1 do
        for j := 0 to length(buckets[i])-1 do
            A[index] := buckets[i][j]
            index := index + 1
        end for
    end for
end procedure`,
                bestCase: "O(n + k)",
                averageCase: "O(n + k)",
                worstCase: "O(n²)",
                explanation: "Bucket sort distributes the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or recursively applying bucket sort. 'n' is the number of elements, 'k' is the number of buckets."
            }
        };

        // Helper functions
        function findMax(arr) {
            return Math.max(...arr);
        }

        function findMin(arr) {
            return Math.min(...arr);
        }

        // Initialize the app
        function init() {
            // Dark mode toggle
            const darkToggle = document.getElementById('dark-mode-toggle');
            darkToggle.addEventListener('change', function() {
                document.body.classList.toggle('dark-mode', this.checked);
                localStorage.setItem('darkMode', this.checked);
            });

            // Load dark mode preference
            if (localStorage.getItem('darkMode') === 'true') {
                darkToggle.checked = true;
                document.body.classList.add('dark-mode');
            }

            updateAlgorithmInfo();
            generateArray();
            
            // Event listeners
            algorithmSelect.addEventListener('change', updateAlgorithmInfo);
            arrayTypeSelect.addEventListener('change', toggleCustomArrayInput);
            generateBtn.addEventListener('click', generateArray);
            startBtn.addEventListener('click', startSorting);
            resetBtn.addEventListener('click', resetVisualization);
            speedControl.addEventListener('input', updateSpeed);
            
            // Initial speed display
            updateSpeed();
        }

        // Update algorithm information display
        function updateAlgorithmInfo() {
            const algorithm = algorithmSelect.value;
            const info = algorithmInfo[algorithm];
            
            pseudoCodeElement.textContent = info.pseudoCode;
            bestCaseElement.textContent = info.bestCase;
            averageCaseElement.textContent = info.averageCase;
            worstCaseElement.textContent = info.worstCase;
        }

        // Toggle custom array input visibility
        function toggleCustomArrayInput() {
            customArrayRow.style.display = arrayTypeSelect.value === 'custom' ? 'flex' : 'none';
        }

        // Update animation speed
        function updateSpeed() {
            const speed = parseInt(speedControl.value);
            speedValue.textContent = speed;
            animationSpeed = 1000 / speed;
        }

        // Generate a new array based on current settings
        function generateArray() {
            const size = parseInt(arraySizeInput.value);
            const type = arrayTypeSelect.value;
            
            if (type === 'custom') {
                const customInput = arrayInput.value.trim();
                if (customInput) {
                    array = customInput.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));
                    if (array.length < 3) {
                        alert("Please enter at least 3 valid numbers separated by commas");
                        array = generateRandomArray(10);
                    }
                } else {
                    array = generateRandomArray(size);
                }
            } else {
                array = [];
                for (let i = 1; i <= size; i++) {
                    array.push(i);
                }
                
                switch (type) {
                    case 'random':
                        shuffleArray(array);
                        break;
                    case 'reverse':
                        array.reverse();
                        break;
                    case 'almost':
                        shuffleArray(array);
                        // Make it almost sorted by swapping a few elements
                        const swaps = Math.floor(size * 0.2);
                        for (let i = 0; i < swaps; i++) {
                            const idx1 = Math.floor(Math.random() * size);
                            const idx2 = Math.floor(Math.random() * size);
                            [array[idx1], array[idx2]] = [array[idx2], array[idx1]];
                        }
                        break;
                    // 'sorted' is already handled by default
                }
            }
            
            // Ensure array size is within limits
            if (array.length > 50) {
                array = array.slice(0, 50);
                alert("Array size limited to 50 elements");
            }
            if (array.length < 3) {
                array = generateRandomArray(10);
            }
            
            // Store the original array
            originalArray = [...array];
            sortedArray = [];
            
            // Update array displays
            updateArrayDisplays();
            
            renderArray();
            resetVisualization();
        }

        // Update array displays
        function updateArrayDisplays() {
            document.getElementById('original-array').textContent = originalArray.join(', ');
            document.getElementById('current-array').textContent = array.join(', ');
            if (sortedArray.length > 0) {
                document.getElementById('sorted-array').textContent = sortedArray.join(', ');
            } else {
                document.getElementById('sorted-array').textContent = "Not sorted yet";
            }
        }

        // Generate a random array
        function generateRandomArray(size) {
            const arr = [];
            for (let i = 0; i < size; i++) {
                arr.push(Math.floor(Math.random() * 100) + 1);
            }
            return arr;
        }

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Render the array as bars
        function renderArray(state = {}) {
            visualization.innerHTML = '';
            const maxValue = Math.max(...array, 1); // Ensure at least 1 to avoid division by zero
            const containerHeight = visualization.clientHeight;
            
            array.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                
                // Calculate height (scale to fit container)
                const height = (value / maxValue) * containerHeight * 0.9;
                bar.style.height = `${height}px`;
                
                // Add value label
                const label = document.createElement('div');
                label.textContent = value;
                label.style.position = 'absolute';
                label.style.bottom = '-20px';
                label.style.width = '100%';
                label.style.textAlign = 'center';
                label.style.fontSize = '12px';
                bar.appendChild(label);
                
                // Apply state classes
                if (state.comparing && (state.comparing.includes(index))) {
                    bar.classList.add('comparing');
                }
                if (state.sorted && state.sorted.includes(index)) {
                    bar.classList.add('sorted');
                }
                if (state.pivot === index) {
                    bar.classList.add('pivot');
                }
                if (state.min === index) {
                    bar.classList.add('min');
                }
                
                visualization.appendChild(bar);
            });
        }

        // Start the sorting process
        function startSorting() {
            if (isSorting) return;
            
            isSorting = true;
            startBtn.disabled = true;
            generateBtn.disabled = true;
            algorithmSelect.disabled = true;
            arraySizeInput.disabled = true;
            arrayTypeSelect.disabled = true;
            arrayInput.disabled = true;
            resetBtn.disabled = false;
            
            // Reset animation frames
            animationFrames = [];
            currentFrame = 0;
            
            // Record start time
            startTime = performance.now();
            
            // Clone the array for sorting
            const sortingArray = [...array];
            
            // Get the selected algorithm
            const algorithm = algorithmSelect.value;
            
            // Clear previous sorted array
            sortedArray = [];
            updateArrayDisplays();
            
            // Execute the appropriate sorting algorithm
            switch (algorithm) {
                case 'bubble':
                    bubbleSort(sortingArray);
                    break;
                case 'insertion':
                    insertionSort(sortingArray);
                    break;
                case 'selection':
                    selectionSort(sortingArray);
                    break;
                case 'merge':
                    mergeSort(sortingArray);
                    break;
                case 'quick':
                    quickSort(sortingArray);
                    break;
                case 'heap':
                    heapSort(sortingArray);
                    break;
                case 'shell':
                    shellSort(sortingArray);
                    break;
                case 'counting':
                    countingSort(sortingArray);
                    break;
                case 'radix':
                    radixSort(sortingArray);
                    break;
                case 'bucket':
                    bucketSort(sortingArray);
                    break;
            }
            
            // Store the sorted array
            sortedArray = [...sortingArray];
            
            // Add final frame where all elements are sorted
            animationFrames.push({
                array: [...sortingArray],
                sorted: Array.from({ length: sortingArray.length }, (_, i) => i)
            });
            
            // Start animation
            animateSorting();
        }

        // Animate the sorting process
        function animateSorting() {
            if (currentFrame >= animationFrames.length) {
                // Sorting complete
                endTime = performance.now();
                const executionTime = (endTime - startTime).toFixed(2);
                actualTimeElement.textContent = `${executionTime} ms`;
                
                // Update the current array display to show the final sorted array
                array = [...sortedArray];
                updateArrayDisplays();
                
                displayTimeComplexity();
                
                isSorting = false;
                return;
            }
            
            const frame = animationFrames[currentFrame];
            
            // Update the current array state for display
            array = [...frame.array];
            updateArrayDisplays();
            
            renderArray(frame);
            currentFrame++;
            
            setTimeout(animateSorting, animationSpeed);
        }

        // Reset the visualization
        function resetVisualization() {
            isSorting = false;
            startBtn.disabled = false;
            generateBtn.disabled = false;
            algorithmSelect.disabled = false;
            arraySizeInput.disabled = false;
            arrayTypeSelect.disabled = false;
            arrayInput.disabled = false;
            resetBtn.disabled = true;
            
            // Reset to original array
            array = [...originalArray];
            sortedArray = [];
            updateArrayDisplays();
            
            renderArray();
            actualTimeElement.textContent = "Not run yet";
            timeEquationElement.textContent = "The time complexity equation will appear here after sorting completes.";
        }

        // Display time complexity explanation
        function displayTimeComplexity() {
            const algorithm = algorithmSelect.value;
            const info = algorithmInfo[algorithm];
            const size = array.length;
            
            let equation = "";
            let solution = "";
            
            switch (algorithm) {
                case 'bubble':
                case 'insertion':
                case 'selection':
                    equation = `O(n²) = O(${size}²) = O(${size * size})`;
                    solution = `For array size ${size}, worst case is proportional to ${size * size}`;
                    break;
                case 'merge':
                case 'heap':
                    equation = `O(n log n) = O(${size} log ${size}) ≈ O(${size} * ${Math.log2(size).toFixed(2)}) ≈ O(${Math.floor(size * Math.log2(size))})`;
                    solution = `For array size ${size}, time complexity is proportional to ${Math.floor(size * Math.log2(size))}`;
                    break;
                case 'quick':
                    equation = `Average: O(n log n) = O(${size} log ${size}) ≈ O(${Math.floor(size * Math.log2(size))})\nWorst: O(n²) = O(${size}²) = O(${size * size})`;
                    solution = `For array size ${size}, average case is proportional to ${Math.floor(size * Math.log2(size))}, but worst case is ${size * size}`;
                    break;
                case 'shell':
                    equation = `Best: O(n log n)\nAverage: Between O(n log n) and O(n²)\nWorst: O(n²) = O(${size}²) = O(${size * size})`;
                    solution = `For array size ${size}, best case is proportional to ${Math.floor(size * Math.log2(size))}, but worst case is ${size * size}`;
                    break;
                case 'counting':
                    const max = Math.max(...array);
                    const min = Math.min(...array);
                    const range = max - min + 1;
                    equation = `O(n + k) = O(${size} + ${range}) = O(${size + range})`;
                    solution = `For array size ${size} and value range ${range}, time complexity is proportional to ${size + range}`;
                    break;
                case 'radix':
                    const maxRadix = Math.max(...array.map(Math.abs));
                    const digits = maxRadix > 0 ? Math.floor(Math.log10(maxRadix)) + 1 : 1;
                    equation = `O(nk) = O(${size} * ${digits}) = O(${size * digits})`;
                    solution = `For array size ${size} and max digits ${digits}, time complexity is proportional to ${size * digits}`;
                    break;
                case 'bucket':
                    equation = `Best: O(n + k)\nAverage: O(n + k)\nWorst: O(n²) = O(${size}²) = O(${size * size})`;
                    solution = `For array size ${size}, best and average cases are linear with the number of buckets, but worst case (when all elements fall into one bucket) is ${size * size}`;
                    break;
            }
            
            timeEquationElement.innerHTML = `<strong>Time Complexity Calculation:</strong><br>${equation}<br><br><strong>Explanation:</strong><br>${solution}<br><br>${info.explanation}`;
        }

        // Sorting algorithms with animation frames

        // Bubble Sort
        function bubbleSort(arr) {
            let n = arr.length;
            let swapped;
            
            do {
                swapped = false;
                for (let i = 0; i < n - 1; i++) {
                    // Record comparison
                    animationFrames.push({
                        array: [...arr],
                        comparing: [i, i + 1]
                    });
                    
                    if (arr[i] > arr[i + 1]) {
                        // Swap elements
                        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
                        swapped = true;
                        
                        // Record swap
                        animationFrames.push({
                            array: [...arr],
                            comparing: [i, i + 1]
                        });
                    }
                }
                n--;
                
                // Mark the last element as sorted
                animationFrames.push({
                    array: [...arr],
                    sorted: Array.from({ length: arr.length - n }, (_, i) => n + i)
                });
            } while (swapped);
        }

        // Insertion Sort
        function insertionSort(arr) {
            for (let i = 1; i < arr.length; i++) {
                let key = arr[i];
                let j = i - 1;
                
                // Record initial position
                animationFrames.push({
                    array: [...arr],
                    comparing: [i, j],
                    sorted: Array.from({ length: i }, (_, idx) => idx)
                });
                
                while (j >= 0 && arr[j] > key) {
                    // Record comparison
                    animationFrames.push({
                        array: [...arr],
                        comparing: [j, j + 1],
                        sorted: Array.from({ length: i }, (_, idx) => idx)
                    });
                    
                    arr[j + 1] = arr[j];
                    j--;
                    
                    // Record shift
                    animationFrames.push({
                        array: [...arr],
                        comparing: [j + 1, j + 2],
                        sorted: Array.from({ length: i }, (_, idx) => idx)
                    });
                }
                
                arr[j + 1] = key;
                
                // Record final position
                animationFrames.push({
                    array: [...arr],
                    sorted: Array.from({ length: i + 1 }, (_, idx) => idx)
                });
            }
        }

        // Selection Sort
        function selectionSort(arr) {
            for (let i = 0; i < arr.length - 1; i++) {
                let minIndex = i;
                
                // Record initial min
                animationFrames.push({
                    array: [...arr],
                    min: minIndex,
                    sorted: Array.from({ length: i }, (_, idx) => idx)
                });
                
                for (let j = i + 1; j < arr.length; j++) {
                    // Record comparison
                    animationFrames.push({
                        array: [...arr],
                        comparing: [minIndex, j],
                        min: minIndex,
                        sorted: Array.from({ length: i }, (_, idx) => idx)
                    });
                    
                    if (arr[j] < arr[minIndex]) {
                        minIndex = j;
                        
                        // Record new min
                        animationFrames.push({
                            array: [...arr],
                            min: minIndex,
                            sorted: Array.from({ length: i }, (_, idx) => idx)
                        });
                    }
                }
                
                if (minIndex !== i) {
                    // Swap elements
                    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
                    
                    // Record swap
                    animationFrames.push({
                        array: [...arr],
                        comparing: [i, minIndex],
                        sorted: Array.from({ length: i + 1 }, (_, idx) => idx)
                    });
                }
                
                // Mark as sorted
                animationFrames.push({
                    array: [...arr],
                    sorted: Array.from({ length: i + 1 }, (_, idx) => idx)
                });
            }
        }

        // Merge Sort
        function mergeSort(arr, left = 0, right = arr.length - 1) {
            if (left >= right) return;
            
            const mid = Math.floor((left + right) / 2);
            
            // Record division
            animationFrames.push({
                array: [...arr],
                comparing: Array.from({ length: right - left + 1 }, (_, i) => left + i)
            });
            
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }

        function merge(arr, left, mid, right) {
            let i = left;
            let j = mid + 1;
            const temp = [];
            
            // Record merge start
            animationFrames.push({
                array: [...arr],
                comparing: [...Array.from({ length: mid - left + 1 }, (_, idx) => left + idx),
                           ...Array.from({ length: right - mid }, (_, idx) => mid + 1 + idx)]
            });
            
            while (i <= mid && j <= right) {
                if (arr[i] <= arr[j]) {
                    temp.push(arr[i++]);
                } else {
                    temp.push(arr[j++]);
                }
            }
            
            while (i <= mid) temp.push(arr[i++]);
            while (j <= right) temp.push(arr[j++]);
            
            for (let k = 0; k < temp.length; k++) {
                arr[left + k] = temp[k];
                
                // Record merge step
                animationFrames.push({
                    array: [...arr],
                    comparing: [left + k],
                    sorted: Array.from({ length: left + k + 1 }, (_, idx) => idx)
                });
            }
        }

        // Quick Sort
        function quickSort(arr, low = 0, high = arr.length - 1) {
            if (low < high) {
                const pi = partition(arr, low, high);
                
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }

        function partition(arr, low, high) {
            const pivot = arr[high];
            let i = low - 1;
            
            // Record pivot selection
            animationFrames.push({
                array: [...arr],
                pivot: high,
                comparing: [high]
            });
            
            for (let j = low; j < high; j++) {
                // Record comparison
                animationFrames.push({
                    array: [...arr],
                    pivot: high,
                    comparing: [j, high]
                });
                
                if (arr[j] < pivot) {
                    i++;
                    // Swap elements
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    
                    // Record swap
                    animationFrames.push({
                        array: [...arr],
                        pivot: high,
                        comparing: [i, j]
                    });
                }
            }
            
            // Swap pivot to correct position
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            
            // Record final pivot position
            animationFrames.push({
                array: [...arr],
                sorted: [i + 1]
            });
            
            return i + 1;
        }

        // Heap Sort
        function heapSort(arr) {
            const n = arr.length;
            
            // Build max heap
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                heapify(arr, n, i);
            }
            
            // Extract elements from heap
            for (let i = n - 1; i > 0; i--) {
                // Move current root to end
                [arr[0], arr[i]] = [arr[i], arr[0]];
                
                // Record swap
                animationFrames.push({
                    array: [...arr],
                    comparing: [0, i],
                    sorted: Array.from({ length: n - i }, (_, idx) => i + idx)
                });
                
                // Heapify reduced heap
                heapify(arr, i, 0);
            }
        }

        function heapify(arr, n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            
            // Record initial heapify
            animationFrames.push({
                array: [...arr],
                comparing: [i, left, right].filter(idx => idx < n),
                min: largest
            });
            
            if (left < n && arr[left] > arr[largest]) {
                largest = left;
            }
            
            if (right < n && arr[right] > arr[largest]) {
                largest = right;
            }
            
            if (largest !== i) {
                // Record new largest
                animationFrames.push({
                    array: [...arr],
                    comparing: [i, largest],
                    min: largest
                });
                
                // Swap and continue heapifying
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                
                // Record swap
                animationFrames.push({
                    array: [...arr],
                    comparing: [i, largest]
                });
                
                heapify(arr, n, largest);
            }
        }

        // Shell Sort
        function shellSort(arr) {
            const n = arr.length;
            let gap = Math.floor(n / 2);
            
            while (gap > 0) {
                for (let i = gap; i < n; i++) {
                    const temp = arr[i];
                    let j = i;
                    
                    // Record initial position
                    animationFrames.push({
                        array: [...arr],
                        comparing: [i, j - gap]
                    });
                    
                    while (j >= gap && arr[j - gap] > temp) {
                        // Record comparison
                        animationFrames.push({
                            array: [...arr],
                            comparing: [j, j - gap]
                        });
                        
                        arr[j] = arr[j - gap];
                        j -= gap;
                        
                        // Record shift
                        animationFrames.push({
                            array: [...arr],
                            comparing: [j, j + gap]
                        });
                    }
                    
                    arr[j] = temp;
                    
                    // Record final position
                    animationFrames.push({
                        array: [...arr]
                    });
                }
                
                gap = Math.floor(gap / 2);
            }
        }

        // Counting Sort
        function countingSort(arr) {
            const max = Math.max(...arr);
            const min = Math.min(...arr);
            const range = max - min + 1;
            const count = new Array(range).fill(0);
            const output = new Array(arr.length);

            // Store counts (offset by min)
            for (let i = 0; i < arr.length; i++) {
                count[arr[i] - min]++;
                animationFrames.push({ array: [...arr], comparing: [i] });
            }

            // Adjust counts to positions
            for (let i = 1; i < range; i++) {
                count[i] += count[i - 1];
            }

            // Build output (reverse order for stability)
            for (let i = arr.length - 1; i >= 0; i--) {
                output[count[arr[i] - min] - 1] = arr[i];
                count[arr[i] - min]--;
                animationFrames.push({ array: [...output].slice(0, arr.length), comparing: [count[arr[i] - min]] });
            }

            // Copy back to original array
            for (let i = 0; i < arr.length; i++) {
                arr[i] = output[i];
                animationFrames.push({ array: [...arr], sorted: Array.from({ length: i + 1 }, (_, idx) => idx) });
            }
        }

        // Radix Sort
        function radixSort(arr) {
            // Split into negatives and positives
            const negatives = arr.filter(x => x < 0).map(x => -x);
            const positives = arr.filter(x => x >= 0);

            // Sort negatives (as positives, then reverse and negate)
            if (negatives.length > 0) {
                radixSortHelper(negatives);
                negatives.reverse();
                for (let i = 0; i < negatives.length; i++) {
                    negatives[i] = -negatives[i];
                }
            }

            // Sort positives
            if (positives.length > 0) {
                radixSortHelper(positives);
            }

            // Combine results
            arr.length = 0;
            arr.push(...negatives, ...positives);
        }

        function radixSortHelper(arr) {
            const max = Math.max(...arr);
            for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                countingSortByDigit(arr, exp);
            }
        }

        function countingSortByDigit(arr, exp) {
            const n = arr.length;
            const output = new Array(n);
            const count = new Array(10).fill(0);
            
            // Store count of occurrences
            for (let i = 0; i < n; i++) {
                const digit = Math.floor(arr[i] / exp) % 10;
                count[digit]++;
                
                // Record digit count
                animationFrames.push({
                    array: [...arr],
                    comparing: [i]
                });
            }
            
            // Change count[i] to be the position of i in output
            for (let i = 1; i < 10; i++) {
                count[i] += count[i - 1];
            }
            
            // Build the output array
            for (let i = n - 1; i >= 0; i--) {
                const digit = Math.floor(arr[i] / exp) % 10;
                output[count[digit] - 1] = arr[i];
                count[digit]--;
                
                // Record placement
                animationFrames.push({
                    array: [...output].slice(0, n),
                    comparing: [count[digit]]
                });
            }
            
            // Copy output to original array
            for (let i = 0; i < n; i++) {
                arr[i] = output[i];
                
                // Record final placement
                animationFrames.push({
                    array: [...arr]
                });
            }
        }

        // Bucket Sort
        function bucketSort(arr) {
            const n = arr.length;
            if (n <= 0) return;

            const maxVal = Math.max(...arr);
            const minVal = Math.min(...arr);
            const range = maxVal - minVal + 1;
            const bucketCount = Math.floor(Math.sqrt(n));
            const buckets = Array.from({ length: bucketCount }, () => []);

            // Scatter elements into buckets (normalized to [0,1))
            for (let i = 0; i < n; i++) {
                const normalized = (arr[i] - minVal) / range;
                const bucketIdx = Math.min(Math.floor(normalized * bucketCount), bucketCount - 1);
                buckets[bucketIdx].push(arr[i]);
                animationFrames.push({ array: [...arr], comparing: [i], pivot: bucketIdx });
            }

            // Sort individual buckets
            for (let i = 0; i < bucketCount; i++) {
                insertionSort(buckets[i]);
            }

            // Concatenate all buckets
            let index = 0;
            for (let i = 0; i < bucketCount; i++) {
                for (let j = 0; j < buckets[i].length; j++) {
                    arr[index++] = buckets[i][j];
                    animationFrames.push({ array: [...arr], comparing: [index - 1], sorted: Array.from({ length: index }, (_, idx) => idx) });
                }
            }
        }

        // Initialize the application
        init();
    </script>
</body>
</html>